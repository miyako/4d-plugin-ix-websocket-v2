/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-ix-websocket.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : ix-websocket
 #	author : miyako
 #	2022/02/24
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-ix-websocket.h"

#define CALLBACK_IN_NEW_PROCESS 0
#define CALLBACK_SLEEP_TIME 29

std::mutex globalMutex; /* for context management */
std::mutex globalMutex1;/* for METHOD_PROCESS_ID */
std::mutex globalMutex2;/* for LISTENER_METHOD */
std::mutex globalMutex3;/* PROCESS_SHOULD_TERMINATE */
std::mutex globalMutex4;/* PROCESS_SHOULD_RESUME */
std::mutex globalMutex5; /* for object reference */
std::mutex globalMutex6; /* for object reference */

std::map<socket_id_t, ix::WebSocket*> _websockets;
std::map<socket_id_t, ix::WebSocketServer*> _websocketservers;

static ix::WebSocketServer * _serverCreate(int port,
                                           const std::string& host,
                                           int backlog,
                                           size_t maxConnections,
                                           int handshakeTimeoutSecs,
                                           int addressFamily,
                                           socket_id_t *idx){

    std::lock_guard<std::mutex> lock(globalMutex6);
    
    ix::WebSocketServer *webSocket = new ix::WebSocketServer(port, host, backlog, maxConnections, handshakeTimeoutSecs, addressFamily);

    socket_id_t i = -1;
    
    while (_websocketservers.find(i) != _websocketservers.end()) {
        i--;
    }
    
    _websocketservers.insert(std::map<socket_id_t, ix::WebSocketServer*>::value_type(i, webSocket));
    
    *idx = i;
    
    return webSocket;
}

static ix::WebSocket * _socketCreate(socket_id_t *idx){

    std::lock_guard<std::mutex> lock(globalMutex5);
    
    ix::WebSocket *webSocket = new ix::WebSocket;

    socket_id_t i = 1;
    
    while (_websockets.find(i) != _websockets.end()) {
        i++;
    }
    
    _websockets.insert(std::map<socket_id_t, ix::WebSocket*>::value_type(i, webSocket));
    
    *idx = i;
    
    return webSocket;
}

static bool _serverDelete(socket_id_t i){
    
    bool success = false;
    
    std::lock_guard<std::mutex> lock(globalMutex6);
        
    std::map<socket_id_t, ix::WebSocketServer*>::iterator pos = _websocketservers.find(i);
    
    if(pos != _websocketservers.end()) {
        
        ix::WebSocketServer *webSocket = pos->second;

        webSocket->stop();
        delete webSocket;

        _websocketservers.erase(pos);
        
        success = true;
    }
 
    return success;
}

static bool _socketDelete(socket_id_t i){
    
    bool success = false;
    
    std::lock_guard<std::mutex> lock(globalMutex5);
        
    std::map<socket_id_t, ix::WebSocket*>::iterator pos = _websockets.find(i);
    
    if(pos != _websockets.end()) {
        
        ix::WebSocket *webSocket = pos->second;

        webSocket->stop();
        delete webSocket;

        _websockets.erase(pos);
        
        success = true;
    }
 
    return success;
}

static void _serverDeleteAll(){
    
    std::lock_guard<std::mutex> lock(globalMutex6);
        
    std::map<socket_id_t, ix::WebSocketServer*>::iterator it;
    
    for(it = _websocketservers.begin(); it != _websocketservers.end(); ++it)
        {
            ix::WebSocketServer *webSocket = it->second;

            webSocket->stop();
            delete webSocket;
        }
    
    _websocketservers.clear();
}

static void _socketDeleteAll(){
    
    std::lock_guard<std::mutex> lock(globalMutex5);
        
    std::map<socket_id_t, ix::WebSocket*>::iterator it;
    
    for(it = _websockets.begin(); it != _websockets.end(); ++it)
        {
            ix::WebSocket *webSocket = it->second;

            webSocket->stop();
            delete webSocket;
        }
    
    _websockets.clear();
}

ix::WebSocketServer*_serverGet(socket_id_t i){
    
    std::lock_guard<std::mutex> lock(globalMutex6);
    
    ix::WebSocketServer *webSocket = NULL;
    
    std::map<socket_id_t, ix::WebSocketServer*>::iterator pos = _websocketservers.find(i);
    
    if(pos != _websocketservers.end()) {
        webSocket = pos->second;
    }
    
    return webSocket;
}

ix::WebSocket*_socketGet(socket_id_t i){
    
    std::lock_guard<std::mutex> lock(globalMutex5);
    
    ix::WebSocket *webSocket = NULL;
    
    std::map<socket_id_t, ix::WebSocket*>::iterator pos = _websockets.find(i);
    
    if(pos != _websockets.end()) {
        webSocket = pos->second;
    }
    
    return webSocket;
}

namespace IXWS
{
    //constants
    process_name_t MONITOR_PROCESS_NAME = (PA_Unichar *)"$\0W\0S\0\0\0";
    process_stack_size_t MONITOR_PROCESS_STACK_SIZE = 0;

    //context management
    std::vector<int> MESSAGE_TYPE;
    std::vector<std::string> MESSAGE_DATA;
    std::vector<socket_id_t> WEBSOCKET_ID;

    //callback management
    C_TEXT LISTENER_METHOD;
    process_number_t METHOD_PROCESS_ID = 0;
    bool PROCESS_SHOULD_TERMINATE = false;
    bool PROCESS_SHOULD_RESUME = false;
}

static void generateUuid(C_TEXT &returnValue) {
    
#if VERSIONMAC
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
    returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
    CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
    NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
    returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
#else
    RPC_WSTR str;
    UUID uuid;
    int len;
    wchar_t *buffer;
    if(UuidCreate(&uuid) == RPC_S_OK){
        if(UuidToString(&uuid, &str)==RPC_S_OK){
            len = (wcslen((const wchar_t *)str)*2)+2;
            buffer = (wchar_t *)malloc(len);if(buffer){
                memset(buffer,0x00, len);
                memcpy(buffer, str, len);
                _wcsupr((wchar_t *)buffer);
                CUTF16String uid = (const PA_Unichar *)buffer;
                returnValue.setUTF16String(&uid);
                free(buffer);
            }
            RpcStringFree(&str);
        }
    }
#endif
}

void listenerLoop() {

    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);

        IXWS::PROCESS_SHOULD_TERMINATE = false;
    }

    /* Current process returns 0 for PA_NewProcess */
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();

    while(!PA_IsProcessDying())
    {
        PA_YieldAbsolute();

        bool PROCESS_SHOULD_RESUME;
        bool PROCESS_SHOULD_TERMINATE;

        if(1)
        {
            PROCESS_SHOULD_RESUME = IXWS::PROCESS_SHOULD_RESUME;
            PROCESS_SHOULD_TERMINATE = IXWS::PROCESS_SHOULD_TERMINATE;
        }

        if(PROCESS_SHOULD_RESUME)
        {
            size_t MESSAGES;

            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex);

                MESSAGES = IXWS::MESSAGE_TYPE.size();
            }

            while(MESSAGES)
            {
                PA_YieldAbsolute();

                if(CALLBACK_IN_NEW_PROCESS)
                {
                    C_TEXT processName;
                    generateUuid(processName);
                    PA_NewProcess((void *)listenerLoopExecuteMethod,
                                  IXWS::MONITOR_PROCESS_STACK_SIZE,
                                  (PA_Unichar *)processName.getUTF16StringPtr());
                }else
                {
                     listenerLoopExecuteMethod();
                }

                if(PROCESS_SHOULD_TERMINATE)
                    break;

                if(1)
                {
                    std::lock_guard<std::mutex> lock(globalMutex);

                    MESSAGES = IXWS::MESSAGE_TYPE.size();
                    PROCESS_SHOULD_TERMINATE = IXWS::PROCESS_SHOULD_TERMINATE;
                }
            }

            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex4);

                IXWS::PROCESS_SHOULD_RESUME = false;
            }

        }else
        {
            PA_PutProcessToSleep(currentProcessNumber, CALLBACK_SLEEP_TIME);
        }

        if(1)
        {
            PROCESS_SHOULD_TERMINATE = IXWS::PROCESS_SHOULD_TERMINATE;
        }

        if(PROCESS_SHOULD_TERMINATE)
            break;
    }

    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);

        IXWS::LISTENER_METHOD.setUTF16String((PA_Unichar *)"\0\0", 0);
    }

    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);

        IXWS::METHOD_PROCESS_ID = 0;
    }
    
    _socketDeleteAll();
    _serverDeleteAll();
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);

        IXWS::MESSAGE_TYPE.clear();
        IXWS::MESSAGE_DATA.clear();
        IXWS::WEBSOCKET_ID.clear();
    }
    
    PA_KillProcess();
}

void listenerLoopStart() {

    if(!IXWS::METHOD_PROCESS_ID)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);

        IXWS::METHOD_PROCESS_ID = PA_NewProcess((void *)listenerLoop,
                                                IXWS::MONITOR_PROCESS_STACK_SIZE,
                                                IXWS::MONITOR_PROCESS_NAME);
    }
}

void listenerLoopFinish() {

    if(IXWS::METHOD_PROCESS_ID)
    {
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex3);

            IXWS::PROCESS_SHOULD_TERMINATE = true;
        }

        PA_YieldAbsolute();

        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex4);

            IXWS::PROCESS_SHOULD_RESUME = true;
        }
    }
}

void listenerLoopExecute() {

    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);

        IXWS::PROCESS_SHOULD_TERMINATE = false;
    }

    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex4);

        IXWS::PROCESS_SHOULD_RESUME = true;
    }

}

void listenerLoopExecuteMethod() {
    
    int __MESSAGE_TYPE;
    std::string __MESSAGE_DATA;
    socket_id_t __WEBSOCKET_ID;
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex);
            
            std::vector<int>::iterator mt;
            std::vector<std::string>::iterator mx;
            std::vector<socket_id_t>::iterator wi;
            
            mt = IXWS::MESSAGE_TYPE.begin();
            mx = IXWS::MESSAGE_DATA.begin();
            wi = IXWS::WEBSOCKET_ID.begin();
            
            __MESSAGE_TYPE = *mt;
            __MESSAGE_DATA = *mx;
            __WEBSOCKET_ID = *wi;
            
            IXWS::MESSAGE_TYPE.erase(mt);
            IXWS::MESSAGE_DATA.erase(mx);
            IXWS::WEBSOCKET_ID.erase(wi);
        }
    
    if(IXWS::LISTENER_METHOD.getUTF16Length() != 0) {
        
        method_id_t methodId = PA_GetMethodID((PA_Unichar *)IXWS::LISTENER_METHOD.getUTF16StringPtr());
        
        if(methodId)
        {
            PA_Variable    params[3];
            params[0] = PA_CreateVariable(eVK_Longint);
            params[1] = PA_CreateVariable(eVK_Longint);
            params[2] = PA_CreateVariable(eVK_Unistring);
            
            PA_SetLongintVariable(&params[0], __MESSAGE_TYPE);
            PA_SetLongintVariable(&params[1], __WEBSOCKET_ID);
            
            C_TEXT t;
            t.setUTF8String((const uint8_t *)__MESSAGE_DATA.c_str(), (uint32_t)__MESSAGE_DATA.length());
            PA_Unistring data = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
            PA_SetStringVariable(&params[2], &data);
            
            PA_ExecuteMethodByID(methodId, params, 3);
            
            PA_ClearVariable(&params[0]);
            PA_ClearVariable(&params[1]);
            PA_ClearVariable(&params[2]);
            
        }else{
            
            PA_Variable    params[4];
            
            params[0] = PA_CreateVariable(eVK_Unistring);
            PA_Unistring method = PA_CreateUnistring((PA_Unichar *)IXWS::LISTENER_METHOD.getUTF16StringPtr());
            PA_SetStringVariable(&params[0], &method);
            
            params[1] = PA_CreateVariable(eVK_Longint);
            params[2] = PA_CreateVariable(eVK_Longint);
            params[3] = PA_CreateVariable(eVK_Blob);
            
            C_TEXT t;
            t.setUTF8String((const uint8_t *)__MESSAGE_DATA.c_str(), (uint32_t)__MESSAGE_DATA.length());
            PA_Unistring data = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
            PA_SetStringVariable(&params[3], &data);

            PA_ExecuteCommandByID(1007, params, 4);
            
            PA_ClearVariable(&params[0]);
            PA_ClearVariable(&params[1]);
            PA_ClearVariable(&params[2]);
            PA_ClearVariable(&params[3]);
        }
    }
}

/*
 
 WinSock is taken care of in the main app...right?
 
 */

static void OnStartup()
{
    ix::initNetSystem();
}

static void OnExit()
{
    ix::uninitNetSystem();
}

static bool IsProcessOnExit()
{
    PA_long32 state, time;

    std::vector<PA_Unichar>buf(33);
    PA_GetProcessInfo(PA_GetCurrentProcessNumber(), &buf[0], &state, &time);
    CUTF16String procName(&buf[0]);
    CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
    return (!procName.compare(exitProcName));
}

static void OnCloseProcess()
{
    if(IsProcessOnExit())
    {
        listenerLoopFinish();
    }
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)OnStartup, NULL);
                break;
                
            case kCloseProcess :
                OnCloseProcess();
                break;
                
            case kServerDeinitPlugin :
            case kDeinitPlugin :
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)OnExit, NULL);
                break;
			// --- ix-websocket
            
			case 1 :
				Websocket_client(params);
				break;
			case 2 :
				Websocket_server(params);
				break;
			case 3 :
				Websocket_client_start(params);
				break;
			case 4 :
				Websocket_server_start(params);
				break;
			case 5 :
				Websocket_client_stop(params);
				break;
			case 6 :
				Websocket_server_stop(params);
				break;
			case 7 :
				Websocket_client_send(params);
				break;
			case 8 :
				Websocket_server_send(params);
				break;
			case 9 :
				Websocket_client_clear(params);
				break;
			case 10 :
				Websocket_server_clear(params);
				break;
			case 11 :
                Websocket_Get_method(params);
				break;
			case 12 :
                Websocket_SET_METHOD(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark Callback

void Websocket_Get_method(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;

    if(1)
    {
        IXWS::LISTENER_METHOD.setReturn(pResult);
    }
}

void Websocket_SET_METHOD(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);

        IXWS::LISTENER_METHOD.fromParamAtIndex(pParams, 1);
    }
 
    listenerLoopStart();
}

#pragma mark Client

static ix::WebSocket *getWebSocket(PA_ObjectRef options) {
    
    ix::WebSocket *webSocket = NULL;
    
    if(options) {
        
        if(ob_is_defined(options, L"id")) {
            webSocket = _socketGet((socket_id_t)ob_get_n(options, L"id"));
        }
        
    }
    
    return webSocket;
}

static void configureClient(ix::WebSocket *webSocket, PA_ObjectRef options) {

    if(webSocket != NULL) {
        
        if(options) {

            std::string URL;
            
            CUTF8String stringValue;
            if(ob_is_defined(options, L"URL")) {
                if(ob_get_s(options, L"URL", &stringValue)){
                    URL = (const char *)stringValue.c_str();
                    webSocket->setUrl(URL);
                }
            }
            
            if(ob_is_defined(options, L"pingInterval")) {
                unsigned int pingInterval = ob_get_n(options, L"pingInterval");
                webSocket->setPingInterval(pingInterval);
            }

            if(ob_is_defined(options, L"enableAutomaticReconnection")) {
                bool enableAutomaticReconnection = ob_get_b(options, L"enableAutomaticReconnection");
                if(enableAutomaticReconnection) {
                    webSocket->enableAutomaticReconnection();
                }else{
                    webSocket->disableAutomaticReconnection();
                }
            }
            
            if(ob_is_defined(options, L"maxWaitBetweenReconnectionRetries")) {
                uint32_t maxWaitBetweenReconnectionRetries = ob_get_n(options, L"maxWaitBetweenReconnectionRetries");
                webSocket->setMaxWaitBetweenReconnectionRetries(maxWaitBetweenReconnectionRetries);
            }
            
            if(ob_is_defined(options, L"enablePong")) {
                bool enablePong = ob_get_b(options, L"enablePong");
                if(enablePong) {
                    webSocket->enablePong();
                }else{
                    webSocket->disablePong();
                }
            }
           
            if(ob_is_defined(options, L"enablePerMessageDeflate")) {
                bool enablePerMessageDeflate = ob_get_b(options, L"enablePerMessageDeflate");
                if(enablePerMessageDeflate) {
                    webSocket->enablePerMessageDeflate();
                }else{
                    webSocket->disablePerMessageDeflate();
                }
            }
                 
            if(ob_is_defined(options, L"headers")) {
                
                PA_ObjectRef headers = ob_get_o(options, L"headers");
                if(headers) {
                    PA_Variable v = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&v, headers);
                    PA_Unistring u = PA_JsonStringify(v, 0);
                    C_TEXT t;
                    t.setUTF16String(&u);
                    CUTF8String u8;
                    t.copyUTF8String(&u8);
                    
                    Json::Value root;
                    Json::CharReaderBuilder builder;
                    std::string errors;
                    
                    Json::CharReader *reader = builder.newCharReader();
                    bool parse = reader->parse((const char *)u8.c_str(),
                                               (const char *)u8.c_str() + u8.size(),
                                               &root,
                                               &errors);
                    delete reader;
                    
                    if(parse)
                    {
                        if(root.isObject())
                        {
                            ix::WebSocketHttpHeaders _headers;
                            
                            for(Json::Value::const_iterator it = root.begin() ; it != root.end() ; it++)
                            {
                                if(it->isString())
                                {
                                    Json::Value key = it.key();
                                    JSONCPP_STRING name = it.name();
                                    _headers[name] = it->asString();
                                }
                            }
                            webSocket->setExtraHeaders(_headers);
                        }
                    }
                    PA_ClearVariable(&v);
                }
            }
            
            ix::SocketTLSOptions TLSOptions;
                        
            if(ob_is_defined(options, L"certFile")) {
                if(ob_get_s(options, L"certFile", &stringValue)){
                    TLSOptions.certFile = (const char *)stringValue.c_str();
                }
            }
            
            if(ob_is_defined(options, L"keyFile")) {
                if(ob_get_s(options, L"keyFile", &stringValue)){
                    TLSOptions.keyFile = (const char *)stringValue.c_str();
                }
            }
            
            if(ob_is_defined(options, L"caFile")) {
                if(ob_get_s(options, L"caFile", &stringValue)){
                    TLSOptions.caFile = (const char *)stringValue.c_str();
                }
            }
            
            if(ob_is_defined(options, L"ciphers")) {
                if(ob_get_s(options, L"ciphers", &stringValue)){
                    TLSOptions.ciphers = (const char *)stringValue.c_str();
                }
            }

            if(ob_is_defined(options, L"tls")) {
                TLSOptions.tls = ob_get_b(options, L"tls");
                webSocket->setTLSOptions(TLSOptions);
            }
        }
        
    }

}

static ix::WebSocket *createWebSocket(PA_ObjectRef options) {

    ix::WebSocket *webSocket = NULL;
    
    if(options) {
        
        socket_id_t idx = 0;
        webSocket = _socketCreate(&idx);
        ob_set_n(options, L"id", idx);

    }
    
    return webSocket;
}

static bool deleteWebSocket(PA_ObjectRef options) {
    
    if(options) {
        
        socket_id_t idx = (socket_id_t)ob_get_n(options, L"id");
        
        return _socketDelete(idx);

    }

    return false;
}

void Websocket_client(PA_PluginParameters params) {

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
    
    ix::WebSocket *webSocket = createWebSocket(options);
    
    if(webSocket != NULL) {

        configureClient(webSocket, options);
        
        socket_id_t idx = (socket_id_t)ob_get_n(options, L"id");
        ob_set_n(returnValue, L"id", idx);
        
        const std::string URL = webSocket->getUrl();
        
        webSocket->setOnMessageCallback([URL,idx](const ix::WebSocketMessagePtr& msg) {
            
                if (msg->type == ix::WebSocketMessageType::Message)
                {
                    Json::Value messageInfo(Json::objectValue);
                             
                    messageInfo["URL"] = URL;
                    
                    messageInfo["str"] = msg->str;
                    messageInfo["binary"] = msg->binary;
                    messageInfo["wireSize"] = (unsigned int)msg->wireSize;
                    
                    Json::StreamWriterBuilder writer;
                    writer["indentation"] = "";
                    std::string json = Json::writeString(writer, messageInfo);
                    
                    IXWS::MESSAGE_DATA.push_back(json);
                    IXWS::MESSAGE_TYPE.push_back((int)msg->type);
                    IXWS::WEBSOCKET_ID.push_back(idx);
                    
                }else
                
                if (msg->type == ix::WebSocketMessageType::Open)
                {
                    Json::Value openInfo(Json::objectValue);
                    
                    openInfo["URL"] = URL;
                    
                    openInfo["uri"] = msg->openInfo.uri;
                    
                    Json::Value headers(Json::objectValue);

                    for (auto it : msg->openInfo.headers)
                    {
                        headers[it.first] = it.second;
                    }
                    
                    openInfo["headers"] = headers;
                    
                    Json::StreamWriterBuilder writer;
                    writer["indentation"] = "";
                    std::string json = Json::writeString(writer, openInfo);
                    
                    IXWS::MESSAGE_DATA.push_back(json);
                    IXWS::MESSAGE_TYPE.push_back((int)msg->type);
                    IXWS::WEBSOCKET_ID.push_back(idx);
                    
                }else
                    
                if (msg->type == ix::WebSocketMessageType::Close)
                {
                    Json::Value closeInfo(Json::objectValue);
                 
                    closeInfo["URL"] = URL;
                    
                    closeInfo["code"] = msg->closeInfo.code;
                    closeInfo["reason"] = msg->closeInfo.reason;
                    closeInfo["remote"] = msg->closeInfo.remote;
                    
                    Json::StreamWriterBuilder writer;
                    writer["indentation"] = "";
                    std::string json = Json::writeString(writer, closeInfo);
                    
                    IXWS::MESSAGE_DATA.push_back(json);
                    IXWS::MESSAGE_TYPE.push_back((int)msg->type);
                    IXWS::WEBSOCKET_ID.push_back(idx);
                    
                }else
                
                if (msg->type == ix::WebSocketMessageType::Error) {
                    
                    Json::Value errorInfo(Json::objectValue);
                    
                    errorInfo["retries"] = msg->errorInfo.retries;
                    errorInfo["wait_time"] = msg->errorInfo.wait_time;
                    errorInfo["http_status"] = msg->errorInfo.http_status;
                    errorInfo["reason"] = msg->errorInfo.reason;
                    errorInfo["decompressionError"] = msg->errorInfo.decompressionError;

                    Json::StreamWriterBuilder writer;
                    writer["indentation"] = "";
                    std::string json = Json::writeString(writer, errorInfo);
                    
                    IXWS::MESSAGE_DATA.push_back(json);
                    IXWS::MESSAGE_TYPE.push_back((int)msg->type);
                    IXWS::WEBSOCKET_ID.push_back(idx);
                }

            listenerLoopExecute();
        });
        
    }
    
    PA_ReturnObject(params, returnValue);
}

void Websocket_client_start(PA_PluginParameters params) {

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
    
    ix::WebSocket *webSocket = getWebSocket(options);
    
    if(webSocket != NULL) {
        
        configureClient(webSocket, options);
        
        int timeoutSecs = 30;
        
        if(ob_is_defined(options, L"timeout")) {
            timeoutSecs = ob_get_n(options, L"timeout");
        }
        
        ix::WebSocketInitResult status = webSocket->connect(timeoutSecs);
                
        PA_ObjectRef headers = PA_CreateObject();
        
        for (auto it : status.headers)
        {
            std::string key = it.first;
            std::string value = it.second;
            ob_set_s(headers, key.c_str(), value.c_str());
        }
        
        ob_set_o(returnValue, L"headers", headers);
        ob_set_n(returnValue, L"http_status", status.http_status);
        ob_set_b(returnValue, L"success", status.success);
        ob_set_s(returnValue, L"uri", status.uri.c_str());
        
        if(status.success) {
            webSocket->start();
        }else{
            ob_set_s(returnValue, L"errorStr", status.errorStr.c_str());
        }
        
    }
    
    PA_ReturnObject(params, returnValue);
}

void Websocket_client_stop(PA_PluginParameters params) {
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
    
    ix::WebSocket *webSocket = getWebSocket(options);
    
    if(webSocket != NULL) {
        
        uint16_t code = ix::WebSocketCloseConstants::kNormalClosureCode;
        
        if(ob_is_defined(options, L"code")) {
            code = (uint16_t)ob_get_n(options, L"code");
        }
        
        std::string reason = ix::WebSocketCloseConstants::kNormalClosureMessage;
        
        CUTF8String stringValue;
        
        if(ob_is_defined(options, L"reason")) {
            if(ob_get_s(options, L"reason", &stringValue)) {
                reason = (const char *)stringValue.c_str();
            }
        }
        
        webSocket->stop(code, reason);
    }
    
    PA_ReturnObject(params, returnValue);
}

void Websocket_client_send(PA_PluginParameters params) {

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
    
    ob_set_b(returnValue, L"success", false);
    
    ix::WebSocket *webSocket = getWebSocket(options);
    
    if(webSocket != NULL) {
        
        std::string message;
        
        CUTF8String stringValue;
        if(ob_is_defined(options, L"message")) {
            if(ob_get_s(options, L"message", &stringValue)){
                message = (const char *)stringValue.c_str();
               
                ix::WebSocketSendInfo sendInfo = webSocket->sendText(message);
                
                ob_set_b(returnValue, L"success", sendInfo.success);
                ob_set_b(returnValue, L"compressionError", sendInfo.compressionError);
                ob_set_n(returnValue, L"payloadSize", sendInfo.payloadSize);
                ob_set_n(returnValue, L"wireSize", sendInfo.wireSize);
            }
        }
    }

    PA_ReturnObject(params, returnValue);
}

void Websocket_client_clear(PA_PluginParameters params) {

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
    
    ob_set_b(returnValue, L"success", deleteWebSocket(options));
    
    PA_ReturnObject(params, returnValue);
}

#pragma mark Server

static ix::WebSocketServer *getWebSocketServer(PA_ObjectRef options) {
    
    ix::WebSocketServer *webSocket = NULL;
    
    if(options) {
        
        if(ob_is_defined(options, L"id")) {
            webSocket = _serverGet((socket_id_t)ob_get_n(options, L"id"));
        }
        
    }
    
    return webSocket;
}

static void configureServer(ix::WebSocketServer *webSocket, PA_ObjectRef options) {

    if(webSocket != NULL) {
        
        if(options) {
                        
            if(ob_is_defined(options, L"enablePong")) {
                bool enablePong = ob_get_b(options, L"enablePong");
                if(enablePong) {
                    webSocket->enablePong();
                }else{
                    webSocket->disablePong();
                }
            }
           
            if(ob_is_defined(options, L"enablePerMessageDeflate")) {
                bool enablePerMessageDeflate = ob_get_b(options, L"enablePerMessageDeflate");
                if(enablePerMessageDeflate) {

                }else{
                    webSocket->disablePerMessageDeflate();
                }
            }
         
            ix::SocketTLSOptions TLSOptions;
            
            CUTF8String stringValue;
            
            if(ob_is_defined(options, L"certFile")) {
                if(ob_get_s(options, L"certFile", &stringValue)){
                    TLSOptions.certFile = (const char *)stringValue.c_str();
                }
            }
            
            if(ob_is_defined(options, L"keyFile")) {
                if(ob_get_s(options, L"keyFile", &stringValue)){
                    TLSOptions.keyFile = (const char *)stringValue.c_str();
                }
            }
            
            if(ob_is_defined(options, L"caFile")) {
                if(ob_get_s(options, L"caFile", &stringValue)){
                    TLSOptions.caFile = (const char *)stringValue.c_str();
                }
            }
            
            if(ob_is_defined(options, L"ciphers")) {
                if(ob_get_s(options, L"ciphers", &stringValue)){
                    TLSOptions.ciphers = (const char *)stringValue.c_str();
                }
            }

            if(ob_is_defined(options, L"tls")) {
                TLSOptions.tls = ob_get_b(options, L"tls");
                webSocket->setTLSOptions(TLSOptions);
            }

        }
        
    }

}

static ix::WebSocketServer *createWebSocketServer(PA_ObjectRef options) {

    ix::WebSocketServer *webSocket = NULL;
    
    int port = ix::SocketServer::kDefaultPort;
    std::string host = ix::SocketServer::kDefaultHost;
    int backlog = ix::SocketServer::kDefaultTcpBacklog;
    size_t maxConnections = ix::SocketServer::kDefaultMaxConnections;
    int handshakeTimeoutSecs = ix::WebSocketServer::kDefaultHandShakeTimeoutSecs;
    int addressFamily = ix::SocketServer::kDefaultAddressFamily;
    
    if(options) {
        
        if(ob_is_defined(options, L"port")) {
            port = ob_get_n(options, L"port");
        }
        
        if(ob_is_defined(options, L"backlog")) {
            backlog = ob_get_n(options, L"backlog");
        }
       
        if(ob_is_defined(options, L"handshakeTimeoutSecs")) {
            handshakeTimeoutSecs = ob_get_n(options, L"handshakeTimeoutSecs");
        }
        
        if(ob_is_defined(options, L"addressFamily")) {
            addressFamily = ob_get_n(options, L"addressFamily");
        }
        
        if(ob_is_defined(options, L"maxConnections")) {
            maxConnections = ob_get_n(options, L"maxConnections");
        }
        
        CUTF8String stringValue;
        if(ob_is_defined(options, L"host")) {
            if(ob_get_s(options, L"host", &stringValue)){
                host = (const char *)stringValue.c_str();
            }
        }

        socket_id_t idx = 0;
        webSocket = _serverCreate(port, host, backlog, maxConnections, handshakeTimeoutSecs, addressFamily, &idx);
        ob_set_n(options, L"id", idx);

    }
    
    return webSocket;
}

static bool deleteWebSocketServer(PA_ObjectRef options) {
    
    if(options) {
        
        socket_id_t idx = (socket_id_t)ob_get_n(options, L"id");
        
        return _serverDelete(idx);

    }

    return false;
}

void Websocket_server(PA_PluginParameters params) {

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
        
    ix::WebSocketServer *webSocket = createWebSocketServer(options);
    
    if(webSocket != NULL) {
    
        configureServer(webSocket, options);
        
        socket_id_t idx = (socket_id_t)ob_get_n(options, L"id");
        ob_set_n(returnValue, L"id", idx);
        
        webSocket->setOnClientMessageCallback([idx](std::shared_ptr<ix::ConnectionState> connectionState,
                                                    ix::WebSocket& webSocket,
                                                    const ix::WebSocketMessagePtr& msg) {
                     
            if (msg->type == ix::WebSocketMessageType::Message)
            {
       
                Json::Value messageInfo(Json::objectValue);
                
                messageInfo["uri"] = webSocket.getUrl();
                
                messageInfo["remoteIp"] = connectionState->getRemoteIp();
                messageInfo["remotePort"] = connectionState->getRemotePort();
                                
                messageInfo["str"] = msg->str;
                messageInfo["binary"] = msg->binary;
                messageInfo["wireSize"] = (unsigned int)msg->wireSize;
                
                Json::StreamWriterBuilder writer;
                writer["indentation"] = "";
                std::string json = Json::writeString(writer, messageInfo);

                IXWS::MESSAGE_DATA.push_back(json);
                IXWS::MESSAGE_TYPE.push_back((int)msg->type);
                IXWS::WEBSOCKET_ID.push_back(idx);
                
            }else
                
            if (msg->type == ix::WebSocketMessageType::Open)
            {
                Json::Value openInfo(Json::objectValue);
                                
                openInfo["remoteIp"] = connectionState->getRemoteIp();
                openInfo["remotePort"] = connectionState->getRemotePort();
                
                openInfo["uri"] = msg->openInfo.uri;
                webSocket.setUrl(msg->openInfo.uri);
                
                Json::Value headers(Json::objectValue);

                for (auto it : msg->openInfo.headers)
                {
                    headers[it.first] = it.second;
                }
                
                openInfo["headers"] = headers;
                
                Json::StreamWriterBuilder writer;
                writer["indentation"] = "";
                std::string json = Json::writeString(writer, openInfo);
                
                IXWS::MESSAGE_DATA.push_back(json);
                IXWS::MESSAGE_TYPE.push_back((int)msg->type);
                IXWS::WEBSOCKET_ID.push_back(idx);
                
            }else
                
            if (msg->type == ix::WebSocketMessageType::Close)
            {
                Json::Value closeInfo(Json::objectValue);
                
                closeInfo["uri"] = webSocket.getUrl();
                
                closeInfo["remoteIp"] = connectionState->getRemoteIp();
                closeInfo["remotePort"] = connectionState->getRemotePort();
                
                closeInfo["code"] = msg->closeInfo.code;
                closeInfo["reason"] = msg->closeInfo.reason;
                closeInfo["remote"] = msg->closeInfo.remote;
                
                Json::StreamWriterBuilder writer;
                writer["indentation"] = "";
                std::string json = Json::writeString(writer, closeInfo);
                
                IXWS::MESSAGE_DATA.push_back(json);
                IXWS::MESSAGE_TYPE.push_back((int)msg->type);
                IXWS::WEBSOCKET_ID.push_back(idx);
                
            }else
            
            if (msg->type == ix::WebSocketMessageType::Error) {
                
                Json::Value errorInfo(Json::objectValue);
                
                errorInfo["retries"] = msg->errorInfo.retries;
                errorInfo["wait_time"] = msg->errorInfo.wait_time;
                errorInfo["http_status"] = msg->errorInfo.http_status;
                errorInfo["reason"] = msg->errorInfo.reason;
                errorInfo["decompressionError"] = msg->errorInfo.decompressionError;

                Json::StreamWriterBuilder writer;
                writer["indentation"] = "";
                std::string json = Json::writeString(writer, errorInfo);
                
                IXWS::MESSAGE_DATA.push_back(json);
                IXWS::MESSAGE_TYPE.push_back((int)msg->type);
                IXWS::WEBSOCKET_ID.push_back(idx);
            }
            
            listenerLoopExecute();
        });
          
    }

    PA_ReturnObject(params, returnValue);
}

void Websocket_server_start(PA_PluginParameters params) {

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
        
    ix::WebSocketServer *webSocket = getWebSocketServer(options);
    
    if(webSocket != NULL) {
        
        configureServer(webSocket, options);

        auto res = webSocket->listen();
        if (!res.first)
        {
            ob_set_b(returnValue, L"success", false);
            ob_set_s(returnValue, L"errStr", res.second.c_str());
        }else{
            ob_set_b(returnValue, L"success", true);
            webSocket->start();
        }
    }
    
    PA_ReturnObject(params, returnValue);
}

void Websocket_server_stop(PA_PluginParameters params) {

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
    
    ix::WebSocketServer *webSocket = getWebSocketServer(options);
    
    if(webSocket != NULL) {
        
        webSocket->stop();
    }
    
    PA_ReturnObject(params, returnValue);
}

void Websocket_server_send(PA_PluginParameters params) {

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
        
    PA_CollectionRef statuses = PA_CreateCollection();
    
    ix::WebSocketServer *webSocket = getWebSocketServer(options);
    
    if(webSocket != NULL) {
        
        Json::Value uris(Json::arrayValue);
        
        CUTF8String stringValue;
        
        if(ob_is_defined(options, L"uri")) {
            PA_CollectionRef uri = ob_get_c(options, L"uri");
            if(!uri) {
                CUTF16String stringValue16;
                if(ob_get_a(options, L"uri", &stringValue16)){
                    if(stringValue16.length() != 0){
                        uri = PA_CreateCollection();
                        PA_Variable v = PA_CreateVariable(eVK_Unistring);
                        PA_Unistring value = PA_CreateUnistring((PA_Unichar *)stringValue16.c_str());
                        PA_SetStringVariable(&v, &value);
                        PA_SetCollectionElement(uri, PA_GetCollectionLength(uri), v);
                        PA_ClearVariable(&v);
                    }
                }
            }
            if(uri){
                PA_long32 len = PA_GetCollectionLength(uri);
                for(PA_long32 i = 0; i < len; ++i) {
                    PA_Variable v = PA_GetCollectionElement(uri, i);
                    if(PA_GetVariableKind(v) == eVK_Unistring) {
                        PA_Unistring u = PA_GetStringVariable(v);
                        C_TEXT t;
                        t.setUTF16String(&u);
                        CUTF8String u8;
                        t.copyUTF8String(&u8);
                        std::string s((const char *)u8.c_str());
                        uris.append(s);
                    }
                }
            }
        }
        
        std::string message;

        if(ob_is_defined(options, L"message")) {
            if(ob_get_s(options, L"message", &stringValue)){
                message = (const char *)stringValue.c_str();
                
                std::set<std::shared_ptr<ix::WebSocket>> clients = webSocket->getClients();
                for(auto client : clients) {

                    std::string uri = client->getUrl();
                    
                    bool send = (uris.size() == 0);
                    
                    if(!send){
                        for(Json::Value::const_iterator it = uris.begin() ; it != uris.end() ; it++)
                        {
                            JSONCPP_STRING _uri = it->asString();
                            if(_uri == uri) {
                                send = true;
                                break;
                            }
                        }
                    }

                    if(send) {
                        PA_ObjectRef status = PA_CreateObject();
                        ix::WebSocketSendInfo sendInfo = client->sendText(message);
                        ob_set_s(status, L"uri", uri.c_str());
                        ob_set_b(status, L"success", sendInfo.success);
                        ob_set_b(status, L"compressionError", sendInfo.compressionError);
                        ob_set_n(status, L"payloadSize", sendInfo.payloadSize);
                        ob_set_n(status, L"wireSize", sendInfo.wireSize);
                        
                        PA_Variable v = PA_CreateVariable(eVK_Object);
                        PA_SetObjectVariable(&v, status);
                        PA_SetCollectionElement(statuses, PA_GetCollectionLength(statuses), v);
                    }
                }
            }
        }
    }
    
    ob_set_c(returnValue, L"statuses", statuses);
    PA_ReturnObject(params, returnValue);
}

void Websocket_server_clear(PA_PluginParameters params) {

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
    
    ob_set_b(returnValue, L"success", deleteWebSocketServer(options));
    
    PA_ReturnObject(params, returnValue);
}
